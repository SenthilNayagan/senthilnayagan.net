<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8"><title>The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing | Senthil Nayagan</title>
  <meta name="description" content="Rust's ownership and borrowing features prevent us from experiencing memory-related problems. Rust is a great choice when performance matters and it solves pain points that bother many other languages.">
  <meta name="keywords" content="ownership, borrowing, memory-management">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Senthil Nayagan">
  <link rel="canonical" href="https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"><style>@font-face{font-family:body-fallback-1;src:local('Segoe UI');ascent-override:108.8942%;descent-override:42.5368%;size-adjust:94.0362%}@font-face{font-family:body-fallback-2;src:local('Arial');ascent-override:108.6538%;descent-override:42.4429%;size-adjust:94.2442%}@font-face{font-family:body-fallback-3;src:local('Roboto');ascent-override:108.774%;descent-override:42.4899%;size-adjust:94.1401%}@font-face{font-family:body-fallback-4;src:local('Ubuntu');ascent-override:111.5077%;descent-override:43.5577%;size-adjust:91.8322%}@font-face{font-family:mono-fallback;src:local("Menlo"),local("Courier New");size-adjust:80%}@font-face{font-family:"Source Sans";font-style:normal;font-weight:200 900;font-display:swap;src:local("SourceSansVF"),url("/assets/fonts/sourcesans-variable-latin-roman.woff2") format("woff2 supports variations"),url("/assets/fonts/sourcesans-variable-latin-roman.woff2") format("woff2-variations")}@font-face{font-family:"Source Sans";font-style:italic;font-weight:200 900;font-display:swap;src:local("SourceSansItalicVF"),url("/assets/fonts/sourcesans-variable-latin-italic.woff2") format("woff2 supports variations"),url("/assets/fonts/sourcesans-variable-latin-italic.woff2") format("woff2-variations")}@font-face{font-family:"Source Code Pro";font-style:normal;font-display:swap;src:local("SourceCodeVF"),url("/assets/fonts/sourcecode-latin-roman-variable.woff2") format("woff2 supports variations"),url("/assets/fonts/sourcecode-latin-roman-variable.woff2") format("woff2-variations");size-adjust:79%;ascent-override:94%;descent-override:26%}html{--font-family-body:Source Sans,body-fallback-1,body-fallback-2,body-fallback-3,body-fallback-4;--font-weight-body-regular:400;--font-weight-body-bold:700;--font-family-mono:Source Code Pro,mono-fallback,monospace;--font-weight-mono-regular:400;--font-weight-mono-bold:700}body{font-family:var(--font-family-body);font-weight:var(--font-weight-body-regular)}code{font-family:var(--font-family-mono)}</style><link rel="stylesheet" href="/assets/styles/main.css"><link href="/assets/images/favicons/favicon-16.png" rel="icon" sizes="16x16">
<link href="/assets/images/favicons/favicon-32.png" rel="icon" sizes="32x32">
<link href="/assets/images/favicons/favicon-57.png" rel="icon" sizes="57x57">
<link href="/assets/images/favicons/favicon-76.png" rel="icon" sizes="76x76">
<link href="/assets/images/favicons/favicon-96.png" rel="icon" sizes="96x96">
<link href="/assets/images/favicons/favicon-128.png" rel="icon" sizes="128x128">
<link href="/assets/images/favicons/favicon-180.png" rel="apple-touch-icon">
<link href="/assets/images/favicons/favicon-192.png" rel="icon" sizes="192x192">
<link href="/assets/images/favicons/favicon-228.png" rel="icon" sizes="228x228"><script>(function(){const t={AUTO:"auto",LIGHT:"light",DARK:"dark"},c="theme",n=document.documentElement,o=localStorage.getItem(c)||t.LIGHT;n.dataset[c]=o,document.addEventListener("DOMContentLoaded",()=>{if(!document.getElementById("theme-picker"))return;const e=document.getElementById("theme-toggle");!e||(e.addEventListener("change",()=>{const d=e.checked?t.DARK:t.LIGHT;n.dataset[c]=d,localStorage.setItem(c,d)}),o===t.DARK?e.checked=!0:e.checked=!1)})})();
</script><script src="/assets/scripts/index.mjs" type="module"></script><meta property="og:title" content="The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing | Senthil Nayagan"><meta property="og:description" content="Rust's ownership and borrowing features prevent us from experiencing memory-related problems. Rust is a great choice when performance matters and it solves pain points that bother many other languages.">
  <meta property="og:url" content="https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/">
  <meta property="og:type" content="article">
  <meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary">
  <meta name="twitter:creator" content="@SenthilNayagan">
  <meta name="twitter:title" content="The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing | Senthil Nayagan">
  <meta name="twitter:description" content="Rust's ownership and borrowing features prevent us from experiencing memory-related problems. Rust is a great choice when performance matters and it solves pain points that bother many other languages.">
      <link rel="preload" as="style" type="text/css" href="/assets/styles/main.css" >
      <link rel="preload" as="font" type="font/woff2" href="/assets/fonts/sourcesans-variable-latin-roman.woff2" crossorigin>
      <link rel="preload" as="font" type="font/woff2" href="/assets/fonts/sourcesans-variable-latin-roman.woff2" crossorigin>
      <link rel="preload" as="font" type="font/woff2" href="/assets/fonts/sourcecode-latin-roman-variable.woff2" crossorigin><link rel="alternate" type="application/rss+xml" title="RSS Feed for senthilnayagan.net" href="/feed.xml"><noscript><style>#theme-picker-root,.youtube-embed{display:none;}</style></noscript><meta name="generator" content="Eleventy v2.0.0"><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8JWFCGCDB4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8JWFCGCDB4');
</script>
<!-- End Google tag (gtag.js) -->
</head>
<body>
  <header class="navbar">
  <div class="container">
    <nav aria-label="Primary">
      <a href="#page-content" class="screen-reader-only skip-navigation">Skip to content</a>
      <ul class="navbar-links">
        <li>
          <a class="navbar-link-home" href="/" >
            <!-- <span class="site-name">Senthil Nayagan</span> -->
            <img src="/assets/images/logo/logo.png" alt="">
            <!-- <img src="/assets/images/logo/profile.png" alt="Site Logo" class="site-logo"> -->
          </a>
        </li><li><a
            href="/about/"
            class="navbar-link"
            >About</a>
        </li><li><a
            href="/tags/"
            class="navbar-link"
            >Tags</a>
        </li><li class="theme-picker-item">
          <div id="theme-picker" class="theme-toggle">
  <i id="theme-icon" class="fa-solid fa-moon"></i>
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const themeIcon = document.getElementById('theme-icon');
    const currentTheme = localStorage.getItem('theme') || 'light';

    // Set the initial theme
    document.documentElement.setAttribute('data-theme', currentTheme);
    themeIcon.classList.toggle('fa-sun', currentTheme === 'dark');
    themeIcon.classList.toggle('fa-moon', currentTheme === 'light');

    themeIcon.addEventListener('click', () => {
      const newTheme = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      themeIcon.classList.toggle('fa-sun', newTheme === 'dark');
      themeIcon.classList.toggle('fa-moon', newTheme === 'light');
    });
  });
</script>
        </li>        
      </ul>
    </nav>
  </div>
</header><main id="page-content" class="container">
  
<article class="post prose rhythm">
  <header class="post-header">
    <p class="post-date">
      <span class="screen-reader-only">Published </span>
      <i class="fa-regular fa-calendar-days"></i>&nbsp;<time datetime="2024-06-12" >June 12, 2024</time> (Updated <time datetime="2024-07-01" >July 01, 2024</time>)&nbsp;&#183;&nbsp;
      <i class="fa-regular fa-clock"></i>&nbsp;46 min read
    </p>
    <h1 class="post-title">The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing</h1>
    <ul class="post-tags" aria-label="Tags"><li>
          <a href="/tags/ownership/" class="post-tag" aria-label="ownership">ownership</a>
        </li><li>
          <a href="/tags/borrowing/" class="post-tag" aria-label="borrowing">borrowing</a>
        </li><li>
          <a href="/tags/memory-management/" class="post-tag" aria-label="memory-management">memory-management</a>
        </li></ul><p class="spacer"></p>
    <p class="post-subtitle">Rust's ownership and borrowing features prevent us from experiencing memory-related problems. Rust is a great choice when performance matters and it solves pain points that bother many other languages.</p>
    <p class="spacer"></p><!-- Share the post --><div class="social-share">
  <a href="mailto:?subject=The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing&body=https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/" title="Share via Email" target="_blank" aria-label="Share via Email" class="social-icon">
    <i class="fa-regular fa-envelope"></i>
  </a>
  <a href="https://api.whatsapp.com/send?text=The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing%20https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/" title="Share on WhatsApp" target="_blank" aria-label="Share on WhatsApp" class="social-icon">
    <i class="fa-brands fa-whatsapp"></i>
  </a>
  <a href="https://twitter.com/intent/tweet?text=The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing&url=https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/" title="Tweet" target="_blank" aria-label="Share on Twitter" class="social-icon">
    <i class="fa-brands fa-x-twitter"></i>
  </a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/&title=The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing" title="Share on LinkedIn" target="_blank" aria-label="Share on LinkedIn" class="social-icon">
      <i class="fa-brands fa-linkedin"></i>
    </a>
    <!-- <a href="https://www.reddit.com/submit?url=https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/&title=The Secret to Unbreakable Memory Safety: Rust's Ownership and Borrowing" title="Share on Reddit" target="_blank" aria-label="Share on Reddit" class="social-icon">
      <i class="fa-brands fa-reddit"></i>
    </a> --><a href="#" id="copy-link" title="Copy to Clipboard" aria-label="Copy link" class="social-icon">
    <i class="fa-solid fa-link"></i>
  </a>
  <!-- Separator -->
  <!-- <span class="separator">&#183;</span> -->
  <!-- Comment icon -->
  <a href="#comments-section" class="social-icon" id="comments-icon" title="Post Comments">
    <i class="fa-regular fa-comments"></i>
  </a>
  <span id="copy-message" class="copy-message">Copied to clipboard</span>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const copyLink = document.getElementById('copy-link');
    const copyMessage = document.getElementById('copy-message');
    
    copyLink.addEventListener('click', (event) => {
      event.preventDefault(); // Prevent the default link behavior
      const mainUrl = window.location.href.split('#')[0]; // Get URL without hash
      navigator.clipboard.writeText(mainUrl).then(() => {
        copyMessage.style.visibility = 'visible';
        setTimeout(() => {
          copyMessage.style.visibility = 'hidden';
        }, 2000);
      });
    });
  });
</script><figure class="cover-image"><picture class="cover-image">
    <source type="image/webp" srcset="/assets/images/3kiE7FvuqQ-400.webp 400w, /assets/images/3kiE7FvuqQ-800.webp 800w, /assets/images/3kiE7FvuqQ-1792.webp 1792w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/3kiE7FvuqQ-400.jpeg 400w, /assets/images/3kiE7FvuqQ-800.jpeg 800w, /assets/images/3kiE7FvuqQ-1792.jpeg 1792w" sizes="100vw">
    <img width="1792" height="1024" src="/assets/images/3kiE7FvuqQ-1792.jpeg" alt="The Secret to Unbreakable Memory Safety: Rust&#39;s Ownership and Borrowing"  loading="lazy" decoding="async">
  </picture><figcaption><p class="image-description">The harmonious interaction between dog owners and their pets serves as a metaphor for the Rust programming language's approach to memory management through its ownership system.</p><p class="image-credits"><b>Image Credits: </b>Image generated by <b>DALL-E</b>.</p></figcaption></figure></header>
  <div class="rhythm">
    <div class="relative">
    <a href="#toc-skipped" id="skip-toc" class="screen-reader-only">Skip table of contents</a>
</div>
<h3 id="table-of-contents">Table of Contents</h3>
<nav id="toc" class="table-of-contents"><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#overview">Overview</a></li><li class="toc-item"><a class="toc-link" href="#what-is-memory-safety">What is memory safety?</a></li><li class="toc-item"><a class="toc-link" href="#what-is-a-memory-leak">What is a memory leak?</a></li><li class="toc-item"><a class="toc-link" href="#memory-unsafety-vs-memory-leaks">Memory unsafety vs. memory leaks</a></li><li class="toc-item"><a class="toc-link" href="#various-types-of-memories-and-how-they-operate">Various types of memories and how they operate</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#stack-memory-and-how-it-works">Stack memory and how it works</a></li><li class="toc-item"><a class="toc-link" href="#heap-memory-and-how-it-works">Heap memory and how it works</a></li></ol></li><li class="toc-item"><a class="toc-link" href="#how-do-various-other-programming-languages-guarantee-memory-safety">How do various other programming languages guarantee memory safety?</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#manual-or-explicit-memory-deallocation">Manual or explicit memory deallocation</a></li><li class="toc-item"><a class="toc-link" href="#automatic-or-implicit-memory-deallocation">Automatic or implicit memory deallocation</a></li></ol></li><li class="toc-item"><a class="toc-link" href="#how-does-rust-guarantee-memory-safety">How does Rust guarantee memory safety?</a></li><li class="toc-item"><a class="toc-link" href="#ownership">Ownership</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#borrow-checker">Borrow checker</a></li><li class="toc-item"><a class="toc-link" href="#ownership-rules">Ownership rules</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#copy">copy</a></li><li class="toc-item"><a class="toc-link" href="#move">move</a></li><li class="toc-item"><a class="toc-link" href="#clone">clone</a></li></ol></li><li class="toc-item"><a class="toc-link" href="#ownership-rule-1">Ownership rule 1</a></li><li class="toc-item"><a class="toc-link" href="#ownership-rule-2">Ownership rule 2</a></li><li class="toc-item"><a class="toc-link" href="#ownership-rule-3">Ownership rule 3</a></li><li class="toc-item"><a class="toc-link" href="#how-ownership-moves">How ownership moves</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#passing-value-to-a-function">Passing value to a function</a></li><li class="toc-item"><a class="toc-link" href="#returning-from-a-function">Returning from a function</a></li></ol></li></ol></li><li class="toc-item"><a class="toc-link" href="#borrowing">Borrowing</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#following-the-pointer-to-the-value-with-the-dereference-operator">Following the pointer to the value with the dereference operator</a></li><li class="toc-item"><a class="toc-link" href="#references-are-immutable-by-default">References are immutable by default</a></li><li class="toc-item"><a class="toc-link" href="#borrowing-rules">Borrowing rules</a><ol class="toc-list"><li class="toc-item"><a class="toc-link" href="#reference-must-not-outlive-the-owner">Reference must not outlive the owner</a></li><li class="toc-item"><a class="toc-link" href="#many-immutable-references-but-only-one-mutable-reference-allowed">Many immutable references, but only one mutable reference allowed</a></li></ol></li></ol></li><li class="toc-item"><a class="toc-link" href="#closing-remarks">Closing remarks</a></li></ol></nav><div id="toc-skipped"></div>
<h1 id="overview"><a class="to-underline" href="#overview">Overview</a></h1>
<p>The Rust’s <em>ownership</em> and <em>borrowing</em> might be confusing if we don’t grasp what’s really going on. This is particularly true when applying a previously learned programming style to a new paradigm; we call this a <em>paradigm shift</em>. Ownership is a novel idea, yet tricky to understand at first, but it gets easier the more we work on it.</p>
<p>With ownership and borrowing, Rust doesn’t need a “garbage collector,” which incurs runtime overhead as the collector must periodically scan the heap to identify and reclaim unused memory.</p>
<figure class=""><a class="outline-offset" href="/assets/images/0GnSENO69Y-1792.webp"><picture >
    <source type="image/webp" srcset="/assets/images/0GnSENO69Y-400.webp 400w, /assets/images/0GnSENO69Y-800.webp 800w, /assets/images/0GnSENO69Y-1792.webp 1792w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/0GnSENO69Y-400.jpeg 400w, /assets/images/0GnSENO69Y-800.jpeg 800w, /assets/images/0GnSENO69Y-1792.jpeg 1792w" sizes="100vw">
    <img width="1792" height="1024" src="/assets/images/0GnSENO69Y-1792.jpeg" alt="Generated by DALL.E"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 1: </b>Depicting the scene of garbage collectors protesting over job loss, serving as a metaphor for how Rust's ownership and borrowing system eliminates the need for a garbage collector.</p><p class="image-credits"><b>Image Credits: </b>Generated by DALL-E.</p></figcaption></figure>
<p>Before we go further about Rust’s ownership and borrowing, let’s first understand what <em>memory safety</em> and <em>memory leak</em> are and how programming languages deal with them.</p>
<h1 id="what-is-memory-safety"><a class="to-underline" href="#what-is-memory-safety">What is memory safety?</a></h1>
<p>Memory safety refers to the state of a software application where memory pointers or references always refer to valid memory. Because memory corruption is a possibility, there are very few guarantees about a program’s behaviour if it is not memory safe. Simply put, if a program isn’t really memory safe, there are few assurances about its functionality. When dealing with a memory-unsafe program, a malicious party is able to use the flaw to read secrets or execute arbitrary code on someone else’s machine.</p>
<figure class=""><a class="outline-offset" href="/assets/images/BXiOhmkw8n-2000.webp"><picture >
    <source type="image/webp" srcset="/assets/images/BXiOhmkw8n-400.webp 400w, /assets/images/BXiOhmkw8n-800.webp 800w, /assets/images/BXiOhmkw8n-2000.webp 2000w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/BXiOhmkw8n-400.jpeg 400w, /assets/images/BXiOhmkw8n-800.jpeg 800w, /assets/images/BXiOhmkw8n-2000.jpeg 2000w" sizes="100vw">
    <img width="2000" height="1333" src="/assets/images/BXiOhmkw8n-2000.jpeg" alt="Designed by Freepik"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 2: </b>Stealing.</p><p class="image-credits"><b>Image Credits: </b>Designed by Freepik</p></figcaption></figure>
<p>Let’s use a pseudocode to see what valid memory is.</p>
<pre class="language-text"><code data-copyable="true" tabindex="0" class="language-text">// pseudocode #1 - shows valid reference
{ // scope starts here
  int x = 5  
  int y = &amp;x
} // scope ends here
</code></pre>
<p>In the above pseudocode, we’ve created a variable <code>x</code> assigned with a value of <code>10</code>. We use the <code>&amp;</code> operator or keyword to create a reference. Thus, the <code>&amp;x</code> syntax lets us create a reference that refers to the value of <code>x</code>. To put it simply, we’ve created a variable <code>x</code> that owns <code>5</code> and a variable <code>y</code> that is a reference to <code>x</code>.</p>
<p>Since both variables <code>x</code> and <code>y</code> are in the same block or scope, variable <code>y</code> has a valid reference that refers to the value of <code>x</code>. As a result, variable <code>y</code> has a value of <code>5</code>.</p>
<p>Take a look at the below pseudocode. As we can see, the scope of <code>x</code> is limited to the block in which it’s created. We get into dangling references when we try to access <code>x</code> outside of its scope. Dangling reference…? What exactly is it?</p>
<pre class="language-text"><code data-copyable="true" tabindex="0" class="language-text">// pseudocode #2 - shows invalid reference aka dangling reference
{ // scope starts here
  int x = 5
} // scope ends here
int y = &amp;x // can't access x from here; creates dangling reference
</code></pre>
<aside role="note" class="post-aside rhythm"><p><strong>Dangling reference</strong>: A dangling reference is a pointer that points to a memory location that has been given to someone else or released (freed). If a program (aka <em>process</em>) refers to memory that has been released or wiped out, it might crash or cause non-deterministic results.</p>
</aside>
<p>Having said that, <em>memory unsafety</em> is a property of some programming languages that allows programmers to deal with invalid data. As a result, memory unsafety introduced a variety of problems that might cause the following major security vulnerabilities:</p>
<ul>
<li><strong>Out-of-bounds Reads</strong></li>
<li><strong>Out-of-bounds Writes</strong></li>
<li><strong>Use-After-Free</strong></li>
</ul>
<p>Vulnerabilities caused by memory unsafety are at the root of many other serious security threats. Unfortunately, uncovering these vulnerabilities can be extremely challenging for developers.</p>
<hr>
<h1 id="what-is-a-memory-leak"><a class="to-underline" href="#what-is-a-memory-leak">What is a memory leak?</a></h1>
<p>It’s important to understand what a memory leak is and what its consequences are.</p>
<figure class=""><a class="outline-offset" href="/assets/images/NY3J4o21lj-3500.webp"><picture >
    <source type="image/webp" srcset="/assets/images/NY3J4o21lj-400.webp 400w, /assets/images/NY3J4o21lj-800.webp 800w, /assets/images/NY3J4o21lj-3500.webp 3500w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/NY3J4o21lj-400.jpeg 400w, /assets/images/NY3J4o21lj-800.jpeg 800w, /assets/images/NY3J4o21lj-3500.jpeg 3500w" sizes="100vw">
    <img width="3500" height="2100" src="/assets/images/NY3J4o21lj-3500.jpeg" alt="Designed by Freepik"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 3: </b>Leakage.</p><p class="image-credits"><b>Image Credits: </b>Designed by Freepik</p></figcaption></figure>
<p>A <em>memory leak</em> is an unintentional form of memory consumption whereby the developer fails to free an allocated block of <em>heap</em> memory when it is no longer needed. It’s simply the opposite of memory safety. More on the different memory types later, but for now, just know that a <em>stack</em> stores fixed-length variables known at compile time, whereas the size of variables that may change later at runtime must be placed on the <em>heap</em>.</p>
<p>When compared to heap memory allocation, stack memory allocation is considered to be safer since memory is automatically released when it is no longer relevant or necessary, either by the programmer or by the program-runtime itself.</p>
<p>However, when programmers generate memory on the heap and fail to remove it in the absence of a garbage collector (in the case of C and C++), a memory leak develops. Also, if we lose all references to a chunk of memory without deallocating that memory, then we have a memory leak. Our program will continue to own that memory, but it has no way of ever using it again.</p>
<aside role="note" class="post-aside rhythm"><p>A little memory leak is not a problem, but if a program allocates a larger amount of memory and never deallocates it, the program’s memory footprint will continue to rise, resulting in a Denial-of-Service (DoS).</p>
</aside>
<p>When a program exits, the operating system immediately recovers all of the memory it owns. As a result, a memory leak only affects a program while it’s running; it has no effect once the program has terminated.</p>
<p>Let’s go over the key consequences of memory leaks.</p>
<p>Memory leaks reduce the performance of the computer by reducing the amount of available memory (heap memory). It eventually causes the whole or a portion of the system to stop working correctly or to slow down severely. Crashes are commonly linked with memory leaks.</p>
<p>Our approach to figuring out how to prevent memory leaks will vary depending on the programming language we’re using. Memory leaks might begin as a small and nearly “unnoticeable problem”, but they can escalate very quickly and overwhelm the systems they impact. Wherever feasible, we should be on the lookout for them and take action to rectify them rather than leave them to grow.</p>
<hr>
<h1 id="memory-unsafety-vs-memory-leaks"><a class="to-underline" href="#memory-unsafety-vs-memory-leaks">Memory unsafety vs. memory leaks</a></h1>
<p>Memory leaks and memory unsafety are the two types of issues that have received the greatest attention in terms of prevention and remediation. It’s important to note that fixing one does not automatically fix the other.</p>
<figure class=""><a class="outline-offset" href="/assets/images/fuv5Y3ok1X-2022.webp"><picture >
    <source type="image/webp" srcset="/assets/images/fuv5Y3ok1X-400.webp 400w, /assets/images/fuv5Y3ok1X-800.webp 800w, /assets/images/fuv5Y3ok1X-2022.webp 2022w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/fuv5Y3ok1X-400.jpeg 400w, /assets/images/fuv5Y3ok1X-800.jpeg 800w, /assets/images/fuv5Y3ok1X-2022.jpeg 2022w" sizes="100vw">
    <img width="2022" height="1029" src="/assets/images/fuv5Y3ok1X-2022.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 4: </b>Memory unsafety vs. memory leaks.</p></figcaption></figure>
<hr>
<h1 id="various-types-of-memories-and-how-they-operate"><a class="to-underline" href="#various-types-of-memories-and-how-they-operate">Various types of memories and how they operate</a></h1>
<p>Before we go any further, it’s important to understand the different types of memory that our code will use at runtime.</p>
<p>There are two types of memory, as follows, and these memories are structured differently.</p>
<ul>
<li><strong>Processor register</strong></li>
<li><strong>Static</strong></li>
<li><strong>Stack</strong></li>
<li><strong>Heap</strong></li>
</ul>
<p>Both <em>processor register</em> and <em>static</em> memory types are beyond the scope of this post.</p>
<h2 id="stack-memory-and-how-it-works"><a class="to-underline" href="#stack-memory-and-how-it-works">Stack memory and how it works</a></h2>
<p>The stack stores data in the order in which it is received and removes it in the reverse order. Items can be accessed from the stack in the <em>last in, first out</em> (LIFO) order. Adding data onto the stack is called “pushing,” and removing data off the stack is called “popping.”</p>
<p>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change later on must be stored on the heap instead.</p>
<p>As developers, we do not have to worry about stack memory <em>allocation</em> and <em>deallocation</em>; the allocation and deallocation of stack memory is “automatically done” by the compiler. It implies that when data on the stack is no longer relevant (out of scope), it is automatically deleted without the need for our intervention.</p>
<p>This kind of memory allocation is also known as <em>temporary memory allocation</em>, because as soon as the function finishes its execution, all the data that belongs to that function is flushed out of the stack “automatically.”</p>
<aside role="note" class="post-aside rhythm"><p>All primitive types in Rust live on the stack. Types like numbers, characters, slices, booleans, fixed-size arrays, tuples containing primitives, and function pointers can all sit on the stack.</p>
</aside>
<h2 id="heap-memory-and-how-it-works"><a class="to-underline" href="#heap-memory-and-how-it-works">Heap memory and how it works</a></h2>
<p>Unlike a stack, when we put data on the heap, we request a certain amount of space. The memory allocator locates a large enough unoccupied place in the heap, marks it as in use, and returns a reference to that location’s address. This is referred to as <em>allocating</em>.</p>
<p>Allocating on the heap is slower than pushing to the stack because the allocator never has to hunt for an empty location to put new data. Furthermore, because we must follow a pointer to get to data on the heap, it is slower than accessing data on the stack. Unlike the stack, which is allocated and deallocated at compile time, heap memory is allocated and deallocated during the execution of a program’s instructions.</p>
<p>In some programming languages, to allocate heap memory, we use the keyword <code>new</code>. This <code>new</code> keyword (aka <em>operator</em>) denotes a request for memory allocation on the heap. If sufficient memory is available on the heap, the <code>new</code> operator initialises the memory and returns the unique address of that newly allocated memory.</p>
<p>It’s worth mentioning that heap memory is “explicitly” deallocated by the programmer or the runtime.</p>
<hr>
<h1 id="how-do-various-other-programming-languages-guarantee-memory-safety"><a class="to-underline" href="#how-do-various-other-programming-languages-guarantee-memory-safety">How do various other programming languages guarantee memory safety?</a></h1>
<p>When it comes to memory management, particularly heap memory, we’d prefer our programming languages to have the following characteristics:</p>
<ul>
<li>We’d prefer to release memory as soon as possible when it’s no longer needed, with no runtime overhead.</li>
<li>We should never maintain a reference to a data that has been freed (aka a dangling reference). Otherwise, crashes and security issues might occur.</li>
</ul>
<p>Memory safety is ensured in different ways by programming languages by means of:</p>
<ul>
<li><strong>Explicit memory deallocation</strong> (adopted by C, C++)</li>
<li><strong>Automatic or implicit memory deallocation</strong> (adopted by Java, Python, and C#)</li>
<li><strong>Region-based memory management</strong></li>
<li><strong>Linear or unique type systems</strong></li>
</ul>
<p>Both <em>region-based memory management</em> and <em>linear type systems</em> are beyond the scope of this post.</p>
<h2 id="manual-or-explicit-memory-deallocation"><a class="to-underline" href="#manual-or-explicit-memory-deallocation">Manual or explicit memory deallocation</a></h2>
<p>Programmers must “manually” release or erase allocated memory when using explicit memory management. A “deallocation” operator (for instance, <code>delete</code> in C) exists in languages with explicit memory deallocation.</p>
<aside role="note" class="post-aside rhythm"><p>Garbage collection is too costly in systems languages like C and C++, therefore explicit memory allocation continues to exist.</p>
</aside>
<p>Leaving the responsibility of freeing memory to the programmer has the benefit of giving the programmer total control over the life cycle of the variable. However, if deallocation operators are used incorrectly, a software fault may occur during execution. In fact, this manual allocation and releasing process is prone to errors. Some common coding errors include:</p>
<ul>
<li><strong>Dangling reference</strong></li>
<li><strong>Memory leak</strong></li>
</ul>
<p>Despite this, we preferred manual memory management over garbage collection since it gives us more control and provides better performance. Note that the goal of any system programming language is to get as “close to the metal” as possible. In other words, they favour better performance over convenience features in the tradeoff.</p>
<aside role="note" class="post-aside rhythm"><p>It’s entirely our (developers) responsibility to ensure that no pointer to the value we freed is ever used.</p>
</aside>
<p>In the recent past, there have been several proven patterns for avoiding these errors, but it all boils down to maintaining rigorous code discipline, which requires applying the right memory management method consistently.</p>
<p>Key takeaways are:</p>
<ul>
<li>Have greater control over memory management.</li>
<li>Less safety as a result of dangling references and memory leaks.</li>
<li>Results in a longer development time.</li>
</ul>
<h2 id="automatic-or-implicit-memory-deallocation"><a class="to-underline" href="#automatic-or-implicit-memory-deallocation">Automatic or implicit memory deallocation</a></h2>
<p>Automatic memory management has become an essential feature of all modern programming languages, including Java.</p>
<p>In the case of automatic memory deallocation, the <em>garbage collectors</em> serve as an automatic memory managers. These garbage collectors periodically go through the heap and recycle chunks of memory that are not being used. They manage the allocation and release of memory on our behalf. So we don’t have to write code to perform memory management tasks. That’s great since garbage collectors free us from the responsibility of memory management. Another advantage is that it reduces the development time.</p>
<p>Garbage collection, on the other hand, has a number of drawbacks. During garbage collection, the program should pause and spend time determining what it needs to clean up before proceeding.</p>
<p>Furthermore, automatic memory management has higher memory needs. This is due to the fact that a garbage collector performs memory deallocation for us, which consumes both memory and CPU cycles. As a result, automated memory management might degrade application performance, particularly in large applications with limited resources.</p>
<p>Key takeaways are:</p>
<ul>
<li>Eliminates the need for developers to release memory manually.</li>
<li>Provides efficient memory safety with no dangling references or memory leaks.</li>
<li>Simpler and straightforward code.</li>
<li>Faster development cycle.</li>
<li>Have less control over memory management.</li>
<li>Causes latency as it consumes both memory and CPU cycles.</li>
</ul>
<hr>
<h1 id="how-does-rust-guarantee-memory-safety"><a class="to-underline" href="#how-does-rust-guarantee-memory-safety">How does Rust guarantee memory safety?</a></h1>
<p>Some languages provide <em>garbage collection</em>, which looks for memory that is no longer in use while the program runs; others require the programmer to <em>explicitly allocate and release memory</em>. Both of these models have benefits and drawbacks. Garbage collection, though perhaps the most widely used, has some drawbacks; it makes life easy for developers at the expense of resources and performance.</p>
<p>Having said that, one gives efficient memory management <em>control</em>, while the other provides higher <em>safety</em> by eliminating dangling references and memory leaks. Rust combines the benefits of both worlds.</p>
<figure class=""><a class="outline-offset" href="/assets/images/T1hLYpIqhX-566.webp"><picture >
    <source type="image/webp" srcset="/assets/images/T1hLYpIqhX-400.webp 400w, /assets/images/T1hLYpIqhX-566.webp 566w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/T1hLYpIqhX-400.jpeg 400w, /assets/images/T1hLYpIqhX-566.jpeg 566w" sizes="100vw">
    <img width="566" height="505" src="/assets/images/T1hLYpIqhX-566.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 5: </b>Rust has better control over memory management and provide higher safety with no memory issues.</p></figcaption></figure>
<p>Rust takes a different approach to things than the other two, based on an ownership model with a set of rules that the compiler verifies to ensure memory safety. The program will not compile if any of these rules are violated. In fact, ownership replaces runtime garbage collection with compile-time checks for memory safety.</p>
<figure class=""><a class="outline-offset" href="/assets/images/s83HyE3YeP-1554.webp"><picture >
    <source type="image/webp" srcset="/assets/images/s83HyE3YeP-400.webp 400w, /assets/images/s83HyE3YeP-800.webp 800w, /assets/images/s83HyE3YeP-1554.webp 1554w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/s83HyE3YeP-400.jpeg 400w, /assets/images/s83HyE3YeP-800.jpeg 800w, /assets/images/s83HyE3YeP-1554.jpeg 1554w" sizes="100vw">
    <img width="1554" height="578" src="/assets/images/s83HyE3YeP-1554.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 6: </b>Explicit memory management vs. Implicit memory management vs. Rust’s ownership model.</p></figcaption></figure>
<p>It takes some time to get used to ownership because it is a new concept for many programmers, like myself.</p>
<hr>
<h1 id="ownership"><a class="to-underline" href="#ownership">Ownership</a></h1>
<figure class=""><a class="outline-offset" href="/assets/images/cLMuMlijwm-1792.webp"><picture >
    <source type="image/webp" srcset="/assets/images/cLMuMlijwm-400.webp 400w, /assets/images/cLMuMlijwm-800.webp 800w, /assets/images/cLMuMlijwm-1792.webp 1792w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/cLMuMlijwm-400.jpeg 400w, /assets/images/cLMuMlijwm-800.jpeg 800w, /assets/images/cLMuMlijwm-1792.jpeg 1792w" sizes="100vw">
    <img width="1792" height="1024" src="/assets/images/cLMuMlijwm-1792.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 7: </b>Metaphorically reflects Rust's ownership.</p><p class="image-credits"><b>Image Credits: </b>Image generated by DALL-E.</p></figcaption></figure>
<p>At this point, we have a basic understanding of how data is stored in memory. Let’s look at <em>ownership</em> in Rust more closely. Rust’s biggest distinguishing feature is ownership, which ensures memory safety at compile-time.</p>
<p>To begin, let’s define “ownership” in its most literal sense. Ownership is the state of “owning” and “controlling” legal possession of “something”. With that said, we must identify <em>who the owner is</em> and <em>what the owner owns and controls</em>. In Rust, each value has a variable called its <em>owner</em>. To put it simply, a variable is an owner, and the value of a variable is what the owner owns and controls.</p>
<figure class=""><a class="outline-offset" href="/assets/images/FzEesPiBC4-1416.webp"><picture >
    <source type="image/webp" srcset="/assets/images/FzEesPiBC4-400.webp 400w, /assets/images/FzEesPiBC4-800.webp 800w, /assets/images/FzEesPiBC4-1416.webp 1416w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/FzEesPiBC4-400.jpeg 400w, /assets/images/FzEesPiBC4-800.jpeg 800w, /assets/images/FzEesPiBC4-1416.jpeg 1416w" sizes="100vw">
    <img width="1416" height="288" src="/assets/images/FzEesPiBC4-1416.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 8: </b>Variable binding shows the owner and its value/resource.</p></figcaption></figure>
<p>With an ownership model, memory is automatically released (freed) once the variable that owns it goes out of scope. When values go out of scope or their lifetimes end for some other reason, their destructors are called. A destructor, particularly an automated destructor, is a function that removes traces of a value from the program by deleting references and frees up memory.</p>
<h2 id="borrow-checker"><a class="to-underline" href="#borrow-checker">Borrow checker</a></h2>
<p>Rust implements ownership through the <em>borrow checker</em>, a <a href="https://en.wikipedia.org/wiki/Static_program_analysis" target="_blank">static analyzer</a>. The borrow checker is a component in the Rust compiler that keeps track of where data is used throughout the program, and by following ownership rules, it’s able to determine where data needs to be released. Furthermore, the borrow checker ensures that deallocated memory can never be accessed at runtime. It even eliminates the possibility of data races caused by concurrent mutation (modification).</p>
<h2 id="ownership-rules"><a class="to-underline" href="#ownership-rules">Ownership rules</a></h2>
<p>As previously stated, the ownership model is built on a set of rules known as the <em>ownership rules</em>, and these rules are relatively straightforward. The Rust compiler (rustc) enforces these rules:</p>
<ul>
<li>In Rust, each value has a variable called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p>The following memory errors are protected by these compile-time checking ownership rules:</p>
<ul>
<li><strong>Dangling references:</strong> This is where a reference points to a memory address that no longer contains the data to which the pointer was referring; this pointer points to null or random data.</li>
<li><strong>Use after frees:</strong> This is where memory is accessed once it has been freed, which can crash. This memory location can also be used by hackers to execute code.</li>
<li><strong>Double frees:</strong> This is where allocated memory is freed, and then freed again. This might cause the program to crash, potentially exposing sensitive information. This also allows a hacker to run whatever code they choose.</li>
<li><strong>Segmentation faults:</strong> This is where the program tries to access memory it’s not allowed to access.</li>
<li><strong>Buffer overrun:</strong> This is where the volume of data exceeds the storage capacity of the memory buffer, causing the program to crash.</li>
</ul>
<p>Before getting into the details of each ownership rule, it’s important to understand the distinctions between <strong>copy</strong>, <strong>move</strong>, and <strong>clone</strong>.</p>
<h3 id="copy"><a class="to-underline" href="#copy">copy</a></h3>
<p>A type with a fixed size (particularly primitive types) can be stored on the <em>stack</em> and popped off when its scope ends, and may be quickly and easily copied to create a new, independent variable if another part of the code requires the same value in a different scope. Because copying stack memory is cheap and fast, primitive types with a fixed-size are said to have <em>copy</em> semantics. It cheaply creates a perfect replica (a duplicate).</p>
<aside role="note" class="post-aside rhythm"><p>It’s worth noting that primitive types with fixed-size implement the copy trait to make copies.</p>
</aside>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment">// hello</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// hello</span>
</code></pre>
<aside role="note" class="post-aside rhythm"><p>In Rust, there are two kinds of strings: <code>String</code> (heap allocated, and growable) and <code>&amp;str</code> (fixed size, and can’t be mutated).</p>
</aside>
<p>Because <code>x</code> is stored on the stack, copying its value to produce another copy for <code>y</code> is easier. This is not the case for a value that is stored on the heap. This is how the stack frame looks:</p>
<figure class=""><a class="outline-offset" href="/assets/images/3m8GzaG8E_-1416.webp"><picture >
    <source type="image/webp" srcset="/assets/images/3m8GzaG8E_-400.webp 400w, /assets/images/3m8GzaG8E_-800.webp 800w, /assets/images/3m8GzaG8E_-1416.webp 1416w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/3m8GzaG8E_-400.jpeg 400w, /assets/images/3m8GzaG8E_-800.jpeg 800w, /assets/images/3m8GzaG8E_-1416.jpeg 1416w" sizes="100vw">
    <img width="1416" height="612" src="/assets/images/3m8GzaG8E_-1416.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 8: </b>Both `x` and `y` have their own data.</p></figcaption></figure>
<p>Duplicating data increases program runtime and memory consumption. Therefore, copying isn’t a good fit for large chunks of data.</p>
<h3 id="move"><a class="to-underline" href="#move">move</a></h3>
<p>In Rust terminology, “move” means the ownership of the memory is transferred to another owner. Consider the case of complex types that are stored on the heap.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
</code></pre>
<p>We might assume that the second line (i.e. <code>let s2 = s1;</code>) would make a copy of the value in <code>s1</code> and bind it to <code>s2</code>. But this is not the case.</p>
<p>Take a look at the below one to see what’s happening to <code>String</code> under the hood. A String is made up of three parts, which are stored on the <em>stack</em>. The actual contents (hello, in this case) are stored on the <em>heap</em>.</p>
<ul>
<li><strong>Pointer</strong> - points to the memory that holds the contents of the string.</li>
<li><strong>Length</strong> - it’s how much memory, in bytes, the contents of the <code>String</code> is currently using.</li>
<li><strong>Capacity</strong> - it’s the total amount of memory, in bytes, that the <code>String</code> has received from the allocator.</li>
</ul>
<p>To put it in other words, the metadata is kept on the stack while the actual data is kept on the heap.</p>
<figure class=""><a class="outline-offset" href="/assets/images/QKqWjlWxQW-1414.webp"><picture >
    <source type="image/webp" srcset="/assets/images/QKqWjlWxQW-400.webp 400w, /assets/images/QKqWjlWxQW-800.webp 800w, /assets/images/QKqWjlWxQW-1414.webp 1414w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/QKqWjlWxQW-400.jpeg 400w, /assets/images/QKqWjlWxQW-800.jpeg 800w, /assets/images/QKqWjlWxQW-1414.jpeg 1414w" sizes="100vw">
    <img width="1414" height="552" src="/assets/images/QKqWjlWxQW-1414.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 10: </b>The stack holds the metadata while the heap holds the actual contents.</p></figcaption></figure>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> metadata is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. The data representation in memory looks like the one below:</p>
<figure class=""><a class="outline-offset" href="/assets/images/myV3o2w8oE-1520.webp"><picture >
    <source type="image/webp" srcset="/assets/images/myV3o2w8oE-400.webp 400w, /assets/images/myV3o2w8oE-800.webp 800w, /assets/images/myV3o2w8oE-1520.webp 1520w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/myV3o2w8oE-400.jpeg 400w, /assets/images/myV3o2w8oE-800.jpeg 800w, /assets/images/myV3o2w8oE-1520.jpeg 1520w" sizes="100vw">
    <img width="1520" height="1080" src="/assets/images/myV3o2w8oE-1520.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 11: </b>Variable `s2` gets a copy of the pointer, length, and capacity of `s1`.</p></figcaption></figure>
<p>It’s worth noting that the representation does <em>not</em> look like the one below, which is what memory would look like if Rust copied the heap data as well. If Rust performed this, the <code>s2 = s1</code> operation could be extremely slow in terms of runtime performance if the heap data were large.</p>
<figure class=""><a class="outline-offset" href="/assets/images/ejzCsxo5wb-1420.webp"><picture >
    <source type="image/webp" srcset="/assets/images/ejzCsxo5wb-400.webp 400w, /assets/images/ejzCsxo5wb-800.webp 800w, /assets/images/ejzCsxo5wb-1420.webp 1420w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/ejzCsxo5wb-400.jpeg 400w, /assets/images/ejzCsxo5wb-800.jpeg 800w, /assets/images/ejzCsxo5wb-1420.jpeg 1420w" sizes="100vw">
    <img width="1420" height="900" src="/assets/images/ejzCsxo5wb-1420.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 12: </b>If Rust copied the heap data, another possibility for what `let s2 = s1` might do is data replication. However, Rust does not copy by default.</p></figcaption></figure>
<p>Note that when complex types are no longer in scope, Rust will call the <code>drop</code> function to explicitly deallocate heap memory. However, both data pointers in <strong>Figure 11</strong> are pointing to the same location, which is not how Rust works. We will get into the details shortly.</p>
<p>As previously stated, when we assign <code>s1</code> to <code>s2</code>, variable <code>s2</code> receives a copy of <code>s1</code>’s metadata (pointer, length, and capacity). But what happens to <code>s1</code> once it’s been assigned to <code>s2</code>? Rust no longer considers <code>s1</code> to be valid. Yes, you read that correctly.</p>
<p>Let’s think about this <code>let s2 = s1</code> assignment for a moment. Consider what happens if Rust still considers <code>s1</code> as valid after this assignment. When <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the same memory. Uh-oh, that’s not good. This is referred to as a <em>double free error</em>, and it is one of the memory safety bugs. Memory corruption can result from freeing memory twice, posing a security risk.</p>
<p>To ensure memory safety, Rust considered <code>s1</code> invalid after the line <code>let s2 = s1</code>. Therefore, when <code>s1</code> is no longer in scope, Rust does not need to release anything. Examine what happens if we try to use <code>s1</code> after <code>s2</code> has been created.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, world!"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Won't compile. We'll get an error.</span>
</code></pre>
<p>We’ll get an error like the one below because Rust prevents you from using the invalidated reference:</p>
<pre class="language-text"><code tabindex="0" class="language-text">$ cargo run
   Compiling playground v0.0.1 (/playground)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:6:28
  |
3 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
4 |     let s2 = s1;
  |              -- value moved here
5 | 
6 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>As Rust “moved” <code>s1</code>’s ownership of the memory to <code>s2</code> after the line <code>let s2 = s1</code>, it considered <code>s1</code> invalid. Here is the memory representation after s1 has been invalidated:</p>
<figure class=""><a class="outline-offset" href="/assets/images/lLgkIntV8M-1436.webp"><picture >
    <source type="image/webp" srcset="/assets/images/lLgkIntV8M-400.webp 400w, /assets/images/lLgkIntV8M-800.webp 800w, /assets/images/lLgkIntV8M-1436.webp 1436w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/lLgkIntV8M-400.jpeg 400w, /assets/images/lLgkIntV8M-800.jpeg 800w, /assets/images/lLgkIntV8M-1436.jpeg 1436w" sizes="100vw">
    <img width="1436" height="756" src="/assets/images/lLgkIntV8M-1436.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 13: </b>Memory representation after `s1` has been invalidated.</p></figcaption></figure>
<p>When only <code>s2</code> remains valid, it alone will free the memory when it goes out of scope. As a result, the potential for a <em>double free error</em> is eliminated in Rust. That’s wonderful!</p>
<h3 id="clone"><a class="to-underline" href="#clone">clone</a></h3>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the stack data, we can use a method called <code>clone</code>. Here’s an example of how to use the clone method:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {}, s2 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>When using the clone method, the heap data does get copied into s2. This works perfectly and produces the following behaviour:</p>
<figure class=""><a class="outline-offset" href="/assets/images/D7kFX9xKHN-1416.webp"><picture >
    <source type="image/webp" srcset="/assets/images/D7kFX9xKHN-400.webp 400w, /assets/images/D7kFX9xKHN-800.webp 800w, /assets/images/D7kFX9xKHN-1416.webp 1416w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/D7kFX9xKHN-400.jpeg 400w, /assets/images/D7kFX9xKHN-800.jpeg 800w, /assets/images/D7kFX9xKHN-1416.jpeg 1416w" sizes="100vw">
    <img width="1416" height="892" src="/assets/images/D7kFX9xKHN-1416.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 14: </b>When using the clone method, the heap data does get copied into `s2`.</p></figcaption></figure>
<p>The use of the clone method has serious consequences; it not only copies the data, but it also does not synchronize any changes between the two. In general, clones should be planned carefully and with full awareness of the consequences.</p>
<p>By now, we should be able to distinguish between copy, move, and clone. Let’s look at each ownership rule in more detail now.</p>
<h2 id="ownership-rule-1"><a class="to-underline" href="#ownership-rule-1">Ownership rule 1</a></h2>
<p>Each value has a variable called its owner. It implies that all values are owned by variables. In the example below, variable <code>s</code> owns the pointer to our string, and in the second line, variable <code>x</code> owns a value 1.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Rule 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="ownership-rule-2"><a class="to-underline" href="#ownership-rule-2">Ownership rule 2</a></h2>
<p>There can only be one owner of a value at a given time. One can have many pets, but when it comes to the ownership model, there is only one value at any given moment :-)</p>
<figure class=""><a class="outline-offset" href="/assets/images/bAltImWMG7-1480.webp"><picture >
    <source type="image/webp" srcset="/assets/images/bAltImWMG7-400.webp 400w, /assets/images/bAltImWMG7-800.webp 800w, /assets/images/bAltImWMG7-1480.webp 1480w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/bAltImWMG7-400.jpeg 400w, /assets/images/bAltImWMG7-800.jpeg 800w, /assets/images/bAltImWMG7-1480.jpeg 1480w" sizes="100vw">
    <img width="1480" height="947" src="/assets/images/bAltImWMG7-1480.jpeg" alt="Designed by Freepik"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 15: </b>A guy walking with dogs.</p></figcaption></figure>
<p>Let’s look at the example using <em>primitives</em>, which are fixed-size known at compile time.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">let</span> z <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre>
<p>We have taken 10 and assigned it to <code>x</code>; in other words, <code>x</code> owns 10. Then we’re taking <code>x</code> and assigning it to <code>y</code> and we’re also assigning it to <code>z</code>. We know that there can only be one owner at a given time, but we’re not getting any errors here. So what’s going on here is that the compiler is making copies of <code>x</code> every time we assign it to a new variable.</p>
<p>The stack frame for this would be as follows: <code>x = 10</code>, <code>y = 10</code> and <code>z = 10</code>. This, however, does not appear to be the case as this: <code>x = 10</code>, <code>y = x</code>, and <code>z = x</code>. As we know, <code>x</code> is the sole owner of this value 10, and neither <code>y</code> nor <code>z</code> can own this value.</p>
<figure class=""><a class="outline-offset" href="/assets/images/6od6-UU1io-1432.webp"><picture >
    <source type="image/webp" srcset="/assets/images/6od6-UU1io-400.webp 400w, /assets/images/6od6-UU1io-800.webp 800w, /assets/images/6od6-UU1io-1432.webp 1432w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/6od6-UU1io-400.jpeg 400w, /assets/images/6od6-UU1io-800.jpeg 800w, /assets/images/6od6-UU1io-1432.jpeg 1432w" sizes="100vw">
    <img width="1432" height="628" src="/assets/images/6od6-UU1io-1432.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 16: </b>Compiler made copies of `x` to both `y` and `z`.</p></figcaption></figure>
<p>Because copying stack memory is cheap and fast, primitive types with a fixed-size are said to have <em>copy</em> semantics, whereas complex types <em>move</em> ownership, as previously stated. Thus, in this case, the compiler makes the <em>copies</em>.</p>
<p>At this point, the behaviour of <em><a href="https://en.wikipedia.org/wiki/Name_binding" rel="noopener">variable binding</a></em> is similar to that of other programming languages. To illustrate the rules of ownership, we need a complex data type.</p>
<p>Let’s look at data that is stored on the heap and see how Rust understands when to clean it up; the String type is an excellent example for this use case. We’ll focus on String’s ownership-related behaviour; these principles, however, also apply to other complex data types.</p>
<p>The complex type, as we know, manages data on the heap, and its contents are unknown at compile time. Let’s look at the same example we have seen before:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, world!"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Won't compile. We'll get an error.</span>
</code></pre>
<aside role="note" class="post-aside rhythm"><p>In the case of <code>String</code> type, the size might expand and be stored on the heap. This means:</p>
<ul>
<li>At runtime, the memory must be requested from the memory allocator (let’s call it first part).</li>
<li>When we’re done using our <code>String</code>, we need to return (release) this memory back to the allocator (let’s call it second part).</li>
</ul>
<p>We (developers) took care of the first part: when we call <code>String::from</code>, its implementation requests the memory it needs. This part is almost common across programming languages.</p>
<p>However, the second part is different. In languages with a garbage collector (GC), the GC keeps track of and cleans up memory that is no longer in use, and we don’t have to worry about it. In languages without a garbage collector, it’s our responsibility to identify when memory is no longer needed and call for it to be explicitly released. It has always been a challenging programming task to do this correctly:</p>
<ul>
<li>We will waste memory if we forget.</li>
<li>We will have an invalid variable if we do it too early.</li>
<li>We will get a bug if we do it twice.</li>
</ul>
<p>Rust handles memory deallocation in a novel way to make our lives easier: the memory is automatically returned once the variable that owns it goes out of scope.</p>
</aside>
<p>Let’s back to business. In Rust, for complex types, operations like assigning a value to a variable, passing it to a function, or returning it from a function don’t copy the value: <em>they move it</em>. To put it simply, complex types move ownership.</p>
<aside role="note" class="post-aside rhythm"><p>When complex types are no longer in scope, Rust will call the <code>drop</code> function to explicitly deallocate heap memory.</p>
</aside>
<h2 id="ownership-rule-3"><a class="to-underline" href="#ownership-rule-3">Ownership rule 3</a></h2>
<p>When the owner goes out of scope, the value will be dropped. Consider the preceding case again:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, world!"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Won't compile. The value of s1 has already been dropped.</span>
</code></pre>
<p>The value of <code>s1</code> has dropped after <code>s1</code> is assigned to <code>s2</code> (in the <code>let s2 = s1</code> assignment statement). Thus, <code>s1</code> is no longer valid after this assignment. Here is the memory representation after s1 has been dropped:</p>
<figure class=""><a class="outline-offset" href="/assets/images/afCzHr6kT2-1436.webp"><picture >
    <source type="image/webp" srcset="/assets/images/afCzHr6kT2-400.webp 400w, /assets/images/afCzHr6kT2-800.webp 800w, /assets/images/afCzHr6kT2-1436.webp 1436w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/afCzHr6kT2-400.jpeg 400w, /assets/images/afCzHr6kT2-800.jpeg 800w, /assets/images/afCzHr6kT2-1436.jpeg 1436w" sizes="100vw">
    <img width="1436" height="774" src="/assets/images/afCzHr6kT2-1436.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 17: </b>Memory representation after `s1` has been dropped.</p></figcaption></figure>
<h2 id="how-ownership-moves"><a class="to-underline" href="#how-ownership-moves">How ownership moves</a></h2>
<p>There are three ways to transfer ownership from one variable to another in a Rust program:</p>
<ol>
<li>Assigning the value of one variable to another variable (it was already discussed).</li>
<li>Passing value to a function.</li>
<li>Returning from a function.</li>
</ol>
<h3 id="passing-value-to-a-function"><a class="to-underline" href="#passing-value-to-a-function">Passing value to a function</a></h3>
<p>Passing a value to a function has semantics that are similar to assigning a value to a variable. Just like assignment, passing a variable to a function causes it to move or copy. Take a look at this example, which shows both the <em>copy</em> and <em>move</em> use cases:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s comes into scope</span>

    <span class="token function">move_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// s's value moves into the function...</span>
                                    <span class="token comment">// so it's no longer valid from this </span>
																		<span class="token comment">// point forward</span>

    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x comes into scope</span>

    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x would move into the function</span>
                                    <span class="token comment">// It follows copy semantics since it's </span>
																		<span class="token comment">// primitive, so we use x afterward</span>

<span class="token punctuation">}</span> <span class="token comment">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span>
  <span class="token comment">// special happens.</span>


<span class="token keyword">fn</span> <span class="token function-definition function">move_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string comes into scope</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, some_string goes out of scope and `drop` is called. </span>
  <span class="token comment">// The occupied memory is freed.</span>


<span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer comes into scope</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, some_integer goes out of scope. Nothing special happens.</span>
</code></pre>
<p>If we tried to use <code>s</code> after the call to <code>move_ownership</code>, Rust would throw a compile-time error.</p>
<h3 id="returning-from-a-function"><a class="to-underline" href="#returning-from-a-function">Returning from a function</a></h3>
<p>Returning values can also transfer ownership. The example below shows a function that returns a value, with annotations identical to those in the previous example.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership moves its return</span>
                                        <span class="token comment">// value into s1</span>

    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 comes into scope</span>

    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 is moved into</span>
                                        <span class="token comment">// takes_and_gives_back, which also</span>
                                        <span class="token comment">// moves its return value into s3</span>
<span class="token punctuation">}</span> <span class="token comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span>
  <span class="token comment">// happens. s1 goes out of scope and is dropped.</span>


<span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span>             <span class="token comment">// gives_ownership will move its</span>
                                             <span class="token comment">// return value into the function</span>
                                             <span class="token comment">// that calls it</span>

    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"yours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string comes into scope</span>

    some_string                              <span class="token comment">// some_string is returned and</span>
                                             <span class="token comment">// moves out to the calling</span>
                                             <span class="token comment">// function</span>
<span class="token punctuation">}</span>


<span class="token comment">// This function takes a String and returns it</span>
<span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// a_string comes into</span>
                                                      <span class="token comment">// scope</span>

    a_string  <span class="token comment">// a_string is returned and moves out to the calling function</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The ownership of a variable always follows the same pattern: <em>a value is moved when it is assigned to another variable</em>. Unless ownership of the data has been moved to another variable, when a variable that includes data on the heap goes out of scope, the value will be cleaned away by <code>drop</code>.</p>
<p>Hopefully, this gives us a basic understanding of what an <em>ownership</em> model is and how it influences the way Rust handles values, such as assigning them to one another and passing them into and out of functions.</p>
<p>Hold on. One more thing…</p>
<p>Rust’s ownership model, as with all good things, does have certain drawbacks. We quickly realize certain inconveniences once we begin working on Rust. We may have observed that taking ownership and then returning ownership with each function is a little inconvenient.</p>
<figure class=""><a class="outline-offset" href="/assets/images/R3VbWQtxaH-1466.webp"><picture >
    <source type="image/webp" srcset="/assets/images/R3VbWQtxaH-400.webp 400w, /assets/images/R3VbWQtxaH-800.webp 800w, /assets/images/R3VbWQtxaH-1466.webp 1466w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/R3VbWQtxaH-400.jpeg 400w, /assets/images/R3VbWQtxaH-800.jpeg 800w, /assets/images/R3VbWQtxaH-1466.jpeg 1466w" sizes="100vw">
    <img width="1466" height="918" src="/assets/images/R3VbWQtxaH-1466.jpeg" alt="Designed by Freepik"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 18: </b>Woman going through nervous breakdown.</p></figcaption></figure>
<p>It’s annoying that everything we pass into a function must be returned if we want to use it again, in addition to any other data returned by that function. What if we want a function to use a value without taking ownership of it?</p>
<p>Consider the following example. The below code will result in an error because variable, <code>v</code> can no longer be used by the <code>main</code> function (in <code>println!</code>) that initially owned it once the ownership is transferred to the <code>print_vector</code> function.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">print_vector</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this line gives us an error</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">print_vector</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Inside print_vector function {:?}"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Tracking ownership may seem easy enough, but it can get complicated when we start to deal with large and complex programs. So we need a way to transfer values without transferring ownership, which is where the concept of <em>borrowing</em> comes into play.</p>
<hr>
<h1 id="borrowing"><a class="to-underline" href="#borrowing">Borrowing</a></h1>
<p>Borrowing, in its literal sense, refers to receiving something with the promise of returning it. In the context of Rust, <em>borrowing</em> is a way of accessing value without claiming ownership of it, as it must be returned to its owner at some point.</p>
<figure class=""><a class="outline-offset" href="/assets/images/FjalXJPaof-1792.webp"><picture >
    <source type="image/webp" srcset="/assets/images/FjalXJPaof-400.webp 400w, /assets/images/FjalXJPaof-800.webp 800w, /assets/images/FjalXJPaof-1792.webp 1792w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/FjalXJPaof-400.jpeg 400w, /assets/images/FjalXJPaof-800.jpeg 800w, /assets/images/FjalXJPaof-1792.jpeg 1792w" sizes="100vw">
    <img width="1792" height="1024" src="/assets/images/FjalXJPaof-1792.jpeg" alt="Designed by Freepik"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 19: </b>A girl borrows a book from a librarian. Generated by DALL-E.</p></figcaption></figure>
<p>When we borrow a value, we reference its memory address with the <code>&amp;</code> operator. A <code>&amp;</code> is called a <em>reference</em>. The references themselves are nothing special—under the hood, they’re just addresses. For those familiar with C pointers, a reference is a <em>pointer</em> to memory that contains a value that belongs to (aka <em>owned</em> by) another variable. It’s worth noting that a reference can’t be null in Rust. In fact, a <em>reference is a pointer</em>; it’s the most basic type of pointer. There is just one type of pointer in most languages, but Rust has different kinds of pointers, rather than just one. Pointers and their various kinds are a different topic that will be discussed separately.</p>
<p>To put it simply, Rust refers to creating a reference to some value as borrowing the value, which must eventually return to its owner.</p>
<p>Let’s look at a simple example below:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Value y={}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Address of y={:p}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Deref of y={}"</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The above produces the following output:</p>
<pre class="language-text"><code data-copyable="true" tabindex="0" class="language-text">Value y=5
Address of y=0x7fff6c0f131c
Deref of y=5
</code></pre>
<p>Here, the <code>y</code> variable <em>borrows</em> the number <em>owned</em> by variable <code>x</code>, while <code>x</code> still owns the value. We call <code>y</code> a reference to <code>x</code>. The borrow ends when <code>y</code> goes out of scope, and because <code>y</code> does not own the value, it is not destroyed. To borrow a value, take a reference by the <code>&amp;</code> operator. The p formatting, <code>{:p}</code> output as a memory location presented as hexadecimal.</p>
<aside role="note" class="post-aside rhythm"><p><strong>Dereference:</strong> In the above code, “*” (i.e., an asterisk) is a <em>dereference</em> operator that operates on a reference variable. This dereferencing operator allows us to get the value stored in the memory address of a pointer.</p>
</aside>
<p>Let’s look at how a function can use a value without taking ownership through borrowing:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token function">print_vector</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// can access v here as references can't move the value</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">print_vector</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Inside print_vector function {:?}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We are passing a reference (<code>&amp;v</code>) (aka <em>pass-by-reference</em>) to the <code>print_vector</code> function rather than transferring the ownership (i.e., <em>pass-by-value</em>). As a result, after calling the <code>print_vector</code> function in the main function, we can access <code>v</code>.</p>
<h2 id="following-the-pointer-to-the-value-with-the-dereference-operator"><a class="to-underline" href="#following-the-pointer-to-the-value-with-the-dereference-operator">Following the pointer to the value with the dereference operator</a></h2>
<p>As stated previously, a reference is a kind of pointer, and a pointer may be thought of as an arrow pointing to a value stored elsewhere. Consider the below example:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>In the above code, we create a reference to an <code>i32</code> type value and then use the dereference operator to follow the reference to the data. The variable <code>x</code> holds an <code>i32</code> type value, <code>5</code>. We set <code>y</code> equal to a reference to <code>x</code>.</p>
<p>This is how the stack memory appears:</p>
<figure class=""><a class="outline-offset" href="/assets/images/-9VVUjBJ25-1428.webp"><picture >
    <source type="image/webp" srcset="/assets/images/-9VVUjBJ25-400.webp 400w, /assets/images/-9VVUjBJ25-800.webp 800w, /assets/images/-9VVUjBJ25-1428.webp 1428w" sizes="100vw">
<source type="image/jpeg" srcset="/assets/images/-9VVUjBJ25-400.jpeg 400w, /assets/images/-9VVUjBJ25-800.jpeg 800w, /assets/images/-9VVUjBJ25-1428.jpeg 1428w" sizes="100vw">
    <img width="1428" height="206" src="/assets/images/-9VVUjBJ25-1428.jpeg" alt="Created by Author"  loading="lazy" decoding="async">
  </picture></a><figcaption><p class="image-description"><b>Figure 20: </b>Stack memory representation.</p></figcaption></figure>
<p>We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an assertion on the value in <code>y</code>, we must follow the reference to the value it’s referring to using <code>*y</code> (hence dereference here). Once we dereference <code>y</code>, we have access to the integer value that <code>y</code> is pointing to, which we can compare to <code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation error:</p>
<pre class="language-text"><code tabindex="0" class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
  --> src/main.rs:11:5
   |
11 |     assert_eq!(5, y);
   |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
</code></pre>
<p>Because they’re different types, comparing a number and a reference to a number isn’t permitted. Hence, we must use the dereference operator to follow the reference to the value it’s pointing to.</p>
<h2 id="references-are-immutable-by-default"><a class="to-underline" href="#references-are-immutable-by-default">References are immutable by default</a></h2>
<p>Like variable, a reference is immutable by default—it can be made mutable with <code>mut</code>, but only if its owner is also mutable:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> x<span class="token punctuation">;</span>
</code></pre>
<aside role="note" class="post-aside rhythm"><p>Immutable references are also known as <em>shared references</em>, whereas mutable references are also known as <em>exclusive references</em>.</p>
</aside>
<p>Consider the below case. We’re granting read-only access to references since we’re using the <code>&amp;</code> operator instead of <code>&amp;mut</code>. Even if the source <code>n</code> is mutable, <code>ref_to_n</code>, and <code>another_ref_to_n</code> are not, as they are read-only n borrows.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ref_to_n <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
<span class="token keyword">let</span> another_ref_to_n <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
</code></pre>
<p>Borrow checker will give the below error:</p>
<pre class="language-text"><code tabindex="0" class="language-text">error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --> src/main.rs:4:9
  |
3 | let x = 5;
  |     - help: consider changing this to be mutable: `mut x`
4 | let y = &amp;mut x;
  |         ^^^^^^ cannot borrow as mutable
</code></pre>
<h2 id="borrowing-rules"><a class="to-underline" href="#borrowing-rules">Borrowing rules</a></h2>
<p>One could question why a <em>borrowing</em> would not always be preferred over a <em>move</em>. If that’s the case, why does Rust even have <em>move</em> semantic, and why doesn’t it <em>borrow</em> by default? The reason is that borrowing a value in Rust is not always possible. Borrowing is only permitted in certain cases.</p>
<p>Borrowing has its own set of rules, which the <em>borrow checker</em> strictly enforces during compile time. These rules were put in place to prevent <em>data races</em>. They are as follows:</p>
<ol>
<li>The scope of the borrower cannot outlast the scope of the original owner.</li>
<li>There can be multiple immutable references, but only one mutable reference.</li>
<li>Owners can have immutable or mutable references, but not both at the same time.</li>
<li>All references must be valid (can’t be null).</li>
</ol>
<h3 id="reference-must-not-outlive-the-owner"><a class="to-underline" href="#reference-must-not-outlive-the-owner">Reference must not outlive the owner</a></h3>
<p>A reference’s scope must be contained within the scope of the owner of the value. Otherwise, the reference may refer to a freed value, resulting in a <em>use-after-free</em> error.</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">;</span>
<span class="token punctuation">{</span> 
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The above program tries to dereference <code>x</code> after the owner <code>y</code> goes out of scope. Rust prevents this <em>use-after-free</em> error.</p>
<h3 id="many-immutable-references-but-only-one-mutable-reference-allowed"><a class="to-underline" href="#many-immutable-references-but-only-one-mutable-reference-allowed">Many immutable references, but only one mutable reference allowed</a></h3>
<p>We can have as many immutable references (aka shared references) to a particular piece of data at a time, but only one mutable reference (aka exclusive reference) allowed at a moment. This rules exists to eliminate <em>data races</em>. When two references point to the same memory location at the same time, at least one of them is writing, and their actions are <em>not</em> synchronized, this is known as a data race.</p>
<p>We may have as many immutable references as we like because they don’t change the data. Borrowing, on the other hand, restricts us to just keeping one mutable reference (<code>&amp;mut</code>) at a time to prevent the possibility of data races at compile time.</p>
<p>Let’s look at this one:</p>
<pre class="language-rust"><code data-copyable="true" tabindex="0" class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>
    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The above code that attempts to create two mutable references (<code>r1</code> and <code>r2</code>) to <code>s</code> will fail:</p>
<pre class="language-text"><code tabindex="0" class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:6:14
  |
5 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
6 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
7 | 
8 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here
</code></pre>
<hr>
<h1 id="closing-remarks"><a class="to-underline" href="#closing-remarks">Closing remarks</a></h1>
<p>Hopefully, this clarifies the concepts of ownership and borrowing. I also briefly touched on borrow checker, the backbone of ownership and borrowing. As I mentioned at the beginning, ownership is a novel idea that might be difficult to comprehend at first, even for seasoned developers, but gets easier and easier the more you work on it. This is just a rundown of how memory safety is enforced in Rust. I attempted to make this post as easy to understand as possible while yet providing enough information to grasp the concepts. For more details on Rust’s ownership feature, check out their online <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" target="_blank">documentation</a>.</p>
<p>Rust is a great choice when performance matters and it solves pain points that bother many other languages, resulting in a significant step forward with a steep learning curve. For the <strong>seventh year</strong> in a row, <a href="https://survey.stackoverflow.co/2022/#technology-most-loved-dreaded-and-wanted" target="_blank">Rust has been Stack Overflow’s most loved language</a>, with 87% of developers saying they want to continue using it. This implies that many people who have had the chance to use Rust have fallen in love with it. The Rust community continues to grow!</p>
<p><a href="https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results.html" target="_blank">According to the 2023 Annual Rust Survey Results</a>, there is a continued upward year-over-year trend in Rust usage at work. Additionally, 79% of respondents reported that Rust helped their company achieve its goals.</p>
<p>Although Rust has many positive aspects, one of the biggest worries for the future of Rust is that it might become too complex. Let’s keep a close watch on how the language evolves to ensure it maintains ease of use in the future.</p>

    <!-- Comments section -->
    <div id="comments-section">
      <button id="show-comments-button" class="comments-button">Post Comments</button><div id="disqus_thread" style="display: none;"></div>
<script type="text/javascript">
  var disqus_shortname = 'senthilnayagan'; 
  var disqus_developer = 0;

  function loadDisqus() {
    var dsq = document.createElement('script'); 
    dsq.type = 'text/javascript'; 
    dsq.async = true;
    dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }

  var commentsLoaded = false;
  document.getElementById('show-comments-button').addEventListener('click', function() {
    var disqusThread = document.getElementById('disqus_thread');
    if (disqusThread.style.display === 'none') {
      disqusThread.style.display = 'block';
      if (!commentsLoaded) {
        loadDisqus();
        commentsLoaded = true;
      }
      this.textContent = 'Hide Comments';
    } else {
      disqusThread.style.display = 'none';
      this.textContent = 'Post Comments';
    }
  });
</script></div>
  </div>
</article>
<script>
  document.getElementById('comments-icon').addEventListener('click', function(event) {
    event.preventDefault();
    const commentsButton = document.getElementById('show-comments-button');
    if (commentsButton) {
      commentsButton.click();
    }
    setTimeout(() => {
      document.getElementById('comments-section').scrollIntoView({ behavior: 'smooth' });
    }, 300);
  });
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://www.senthilnayagan.net/blog/tech/rust-ownership-and-borrowing/"
    },
    "headline": "The Secret to Unbreakable Memory Safety: Rust&#39;s Ownership and Borrowing",
    "description": "Rust's ownership and borrowing features prevent us from experiencing memory-related problems. Rust is a great choice when performance matters and it solves pain points that bother many other languages.",
    
    "datePublished": "2024-06-12T00:00:00.000Z",
    "dateModified": "2024-07-01T00:00:00.000Z",
    "author": {
      "@type": "Person",
      "name": "Senthil Nayagan"
    }
  }
</script>
</main><footer class="page-footer size-font-sm">
  <div class="page-footer-container container">
    <div class="stack gap--1">
      <p>&copy; 2024 <b>SenthilNayagan.net</b> | Hosted on <b>GitHub Pages</b>.</p>
      <p class="footer-link-font"><a href="/privacyPolicy/" target="_blank">Privacy Policy</a> | <a href="/privacyPolicy/#cookies" target="_blank">Cookie Policy</a> | <a href="/commentPolicy/" target="_blank">Comment Policy</a>  | <a href="/feed.xml" target="_blank">RSS Feed</a> | <a href="/contact/" target="_blank">Contact</a></p>
    </div>
  </div>
</footer>
  <!-- Back to top icon/button -->
  <script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
  <script>addBackToTop({
      diameter: 50,
      backgroundColor: 'rgb(128, 128, 128)',
      textColor: '#fff'
      })
  </script>
  <!-- Include cookie consent -->
  <!-- Cookie Consent Banner -->
<div id="cookie-banner" class="cookie-banner" style="display: none;">
    <p>This site uses cookies to understand the number of visitors and which posts they read the most through Google Analytics. If you consent to this, please click "I Agree." If not, click "I Disagree." For more details, please refer to the <a href="/privacyPolicy/#cookies" target="_blank">Cookie Policy</a>.</p>
    <button id="accept-cookies" class="cookie-button">I Agree</button>
    <button id="decline-cookies" class="cookie-button">I Disagree</button>
</div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
      const cookieBanner = document.getElementById('cookie-banner');
      const acceptCookiesButton = document.getElementById('accept-cookies');
      const declineCookiesButton = document.getElementById('decline-cookies');
  
      function setCookie(name, value, days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = "expires=" + date.toUTCString();
        document.cookie = name + "=" + value + ";" + expires + ";path=/";
      }
  
      function getCookie(name) {
        const decodedCookie = decodeURIComponent(document.cookie);
        const cookieArray = decodedCookie.split(';');
        for(let i = 0; i < cookieArray.length; i++) {
          let cookie = cookieArray[i].trim();
          if (cookie.indexOf(name + "=") == 0) {
            return cookie.substring(name.length + 1, cookie.length);
          }
        }
        return "";
      }
  
      function checkCookie() {
        const cookiesAccepted = getCookie("cookiesAccepted");
        if (cookiesAccepted !== "true" && cookiesAccepted !== "false") {
          cookieBanner.style.display = "block";
        }
      }
  
      acceptCookiesButton.addEventListener('click', () => {
        setCookie("cookiesAccepted", "true", 365);
        cookieBanner.style.display = "none";
      });
  
      declineCookiesButton.addEventListener('click', () => {
        setCookie("cookiesAccepted", "false", 365);
        cookieBanner.style.display = "none";
      });
  
      checkCookie();
    });
</script>
</body>
</html>
